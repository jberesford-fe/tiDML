---
title: "Intro to tiDML"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Intro to tiDML}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knit-options, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
# First pass with tiDML

In the simplest case, you can use the package under complete default settings. Pick a model, specify data, outcome variable, treatment variable, and covariates, and hit go. Currently, the default models available are:

- `dml_rf()` for random forest, and
- `dml_nnet()` for a neural network.

Here I use the `diamonds` data from `ggplot2` to estimate the effect of being rated "ideal" on a diamonds' price, after having controlled for caret, depth, and size.

```{r setup}
library(tiDML)

df <- diamonds_sample(n=500)

fit_rf <- dml_rf(
  data = df,
  y = "price",
  d = "is_rated_ideal",
  x = c("carat", "depth", "table", "x", "y", "z"),
)

fit_rf$estimate

```

# Checking model outputs

A benefit of using `tiDML` (and the `tidymodels` ecosystem more generally) is that you can rely on packages like `generics` and `workflows` to examine the inputs and outputs of your model.

### `tidy()`

Tidy returns a tibble with the point estimate, standard error, t-value, p-value, and confidence interval.

```{r examine-tidy}
# Coefficients and standard errors
generics::tidy(fit_rf)
```

### `glance()` 

Glance returns a tibble with the inputs and settings used for the DML estimation.

```{r examine-glance}
generics::glance(fit_rf)
```

### `augment()`

Augment returns a tibble with the original data, predicted values, and residuals for the outcome and treatment variables. These are out-of-fold predictions and residuals, handy for diagnostics.

```{r examine-augment}
generics::augment(fit_rf) |> head()
```

## Examine the workflow (recipe and model specs)

The workflows package is used to manage the preprocessing and model fitting steps. You can extract the (unfitted) workflow object and examine it. *Note that while the fitted workflow can be extracted, isn't useful here since DML uses cross-fitting.* 

```{r examine-workflow}
# Examine the treatment model workflow
print("Treatment model workflow:")
fit_rf$m_workflow

print("Outcome model workflow:")
fit_rf$g_workflow
```

Much more detail is given in the Articles section. See `vignette("examine-outputs")`.

# Setting your own models

You can also set your own models using `parsnip` and `recipes`. This gives you more control over the model specifications and preprocessing steps. See `vignette("user-defined-recipies")` for instructions.